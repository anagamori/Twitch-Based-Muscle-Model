%==========================================================================
% muscleModel_noTendon.m
% Author: Akira Nagamori
% Last update: 3/4/19
% Descriptions:
%   Full model without tendon
%==========================================================================
%% Simulation parameters
Fs = 1000;
h = 1/Fs;
time = 0:1/Fs:5;
amp = 0.1;
synaptic_drive = [zeros(1,1*Fs) amp/2*[0:1/Fs:2] amp*ones(1,length(time)-1*Fs-length(amp*[0:1/Fs:2]))];

%% Muscle architectural parameters
modelParameter.pennationAngle = 9.6*pi/180; %[radians]
modelParameter.optimalLength = 6.8; % [cm]
modelParameter.tendonSlackLength = 24.1; % [cm]
modelParameter.mass = 0.01; % [g]
modelParameter.muscleInitialLength = 6.8; % [cm]
modelParameter.tendonInitialLength = 24.1; % [cm]

density = 1.06; %
L0 = modelParameter.optimalLength; % optimal muscle length [cm]
mass = modelParameter.mass; % muscle mass [kg]
PCSA = (mass*1000)/(density*L0); % PCSA of muscle
sigma = 31.8; % specific tension
F0 = PCSA * sigma; % maximal force

L_tendon = modelParameter.tendonSlackLength;
L0T = L_tendon*1.05;
alpha = modelParameter.pennationAngle;
Lm_initial = modelParameter.muscleInitialLength; % muscle initial length
Lt_initial = modelParameter.tendonInitialLength; % tendon initial length
Lmt = Lm_initial*cos(alpha)+Lt_initial; % intial musculotendon length

%--------------------------------------------------------------------------
% Motor unit architecture
N_MU = 300; % number of motor units
i_MU = 1:N_MU; % index for motor units

%% Peak tetanic force
RP_MU = 25; %range of peak tension across motor untis in unit of fold
b_MU = log(RP_MU)/N_MU; %coefficient to establish a range of twich force values
P_MU = exp(b_MU*i_MU); %force generated by a motor unit as a function of its recruitment threshold
PTi = P_MU./sum(P_MU)*F0; % peak tetanic force for individual units

%% Fractional PSCA
F_pcsa_slow = 0.3; % fractional PSCA of slow-twitch motor units (0-1)
[~, index_slow] = min(abs(cumsum(PTi) - F0*F_pcsa_slow)); rng(1)

%% Contraction time
% Generate a distribution of contraction time across motor units based on
% Rayleigh distribution
rng(1)
min_CT = 20; %minimum contraction time [ms]
CT = round(raylrnd(23,1,N_MU)+min_CT); %contraction time of individual motor units [ms]
CT_sorted = sort(CT,'descend');
CT_fastest_slow = CT_sorted(index_slow);
mean(CT_sorted(1:index_slow)); %average contraction time of slow-twitch MUs
mean(CT_sorted(index_slow+1:end)); %average contraction time of fast-twitch MUs

load('CT_vec')
[CT_new,index_CT] = sort(CT_vec,'descend');
%% Motor unit parameter
load('pool_parameter_matrix')
parameter_Matrix; %matrix of [N_MU,15]
% N_MU is in order of CT_sorted

%% Assign peak tetanic force into each unit
% shuffle indexes within each fiber type with respect to contraction time
% this will allow us to randomly assign peak tetanic tension to each motor
% unit with different contraction time
rng(1)
R_slow = randperm(index_slow);
index_fast = index_slow+1:N_MU;
R_fast_temp = randperm(length(index_fast));
R_fast = index_fast(R_fast_temp);
index_MU_PTi = [R_slow R_fast]; % vector of indexes to match peak tetanic tension to appropriate contraction time
PTi_new = PTi (index_MU_PTi);


%% Recruitment threshold
% Find recruitment threshold for individual units using exponential fit
% Recruitment threshold is correlated to peak tetanic tension
%   Use index_MU_PTi to appropriately index each MU
Ur = 0.8; % recruitment threshold for the lastly recruited motor unit
Ur_1 = 0.01; % reruitment threshold for the first unit
f_RT = fit([1 N_MU]',[Ur_1 Ur]','exp1');
coeffs_f_RT = coeffvalues(f_RT);
U_th = coeffs_f_RT(1)*exp(coeffs_f_RT(2)*i_MU); % the resulting recruitment threshold for individual units

%% Minimum and maximum firing rate
load('FR_half')
FR_half_new = FR_half(index_CT);
MDR = FR_half_new/2;
PDR = FR_half_new*2;

%% Activation dynamics (Song et al., 2008)
U_eff = 0;
T_U = 0.03;

tau_1 = parameter_Matrix(:,9);
R_temp = exp(-time./tau_1); 
alpha = parameter_Matrix(:,15);
%% Discharge rate parameters
cv_MU = 0; % coefficient of variation for interspike intervals

%% Muscle length
Lce = 1;
Vce = 0;
%% Initilization
spike_time = zeros(N_MU,1);
spike_train = zeros(N_MU,length(time));
force = zeros(N_MU,length(time));
Force = zeros(1,length(time));
R = zeros(N_MU,length(time));
x = zeros(N_MU,1);
y = zeros(N_MU,1);
z = zeros(N_MU,1);

x_mat = zeros(N_MU,length(time));
y_mat = zeros(N_MU,length(time));
z_mat = zeros(N_MU,length(time));

S = zeros(N_)
Y = 0;
%% Simulation
for t = 1:length(time)
    %% Effective activation (Song et al., 2008)
    U_eff_dot = (synaptic_drive(t) - U_eff)/T_U;
    U_eff = U_eff_dot*1/Fs + U_eff;
    
    %% Calculate firing rate
    % Linear increase in discharge rate up to Ur
    DR_MU = (PDR-MDR)./(1-U_th).*(U_eff-U_th) + MDR;
    % Zero the discharge rate of a MU if it is smaller than its minimum
    % firing rate
    DR_MU(DR_MU<MDR) = 0;
    
    %% Sag & Yield (Song et al., 2008)
    Y = yield_function(Y,Vce,Fs);
    %% Convert activation into spike trains
    for n = 1:length(find(DR_MU>=MDR)) % loop through motor units whose firing rate is greater than minimum firing rate defined by the user
        spike_train_temp = zeros(1,length(t));
        if ~any(spike_train(n,:)) % when the motor unit fires at the first time
            spike_train(n,t) = 1; % add a spike to the vector
            spike_train_temp(t) = 1;
            mu = 1/DR_MU(n);
            Z = randn(1);
            Z(Z>3.9) = 3.9;
            Z(Z<-3.9) = -3.9;
            spike_time_temp = (mu + mu*cv_MU*Z)*Fs;
            spike_time(n) = round(spike_time_temp) + t;
            
            temp = conv(spike_train_temp,R_temp(n,:)*(1+2*z(n)^alpha(n)));
            R(n,:) = R(n,:) + temp(1:length(time));
        else % when the motor unit have already fired at least once
            if spike_time(n) == t % when the motor unit fires
                spike_train(n,t) = 1;
                spike_train_temp(t) = 1;
                % update mean firing rate of the motor unit given the
                % current value of input
                mu = 1/DR_MU(n); % interspike interval
                Z = randn(1);
                Z(Z>3.9) = 3.9;
                Z(Z<-3.9) = -3.9;
                spike_time_temp = (mu + mu*cv_MU*Z)*Fs; % interspike interval
                spike_time(n) = round(spike_time_temp) + t;
                
                temp = conv(spike_train_temp,R_temp(n,:)*(1+2*z(n)^alpha(n)));
                R(n,:) = R(n,:) + temp(1:length(time));
            elseif t > spike_time(n) + round(1/DR_MU(n)*Fs)
                spike_train(n,t) = 1;
                spike_train_temp(t) = 1;
                spike_time(n) = t;
                mu = 1/DR_MU(n); % interspike interval
                Z = randn(1);
                Z(Z>3.9) = 3.9;
                Z(Z<-3.9) = -3.9;
                spike_time_temp = (mu + mu*cv_MU*Z)*Fs; % interspike interval
                spike_time(n) = round(spike_time_temp) + t;
                
                temp = conv(spike_train_temp,R_temp(n,:)*(1+2*z(n)^alpha(n)));
                R(n,:) = R(n,:) + temp(1:length(time));
            end
        end
    end
    
    %% Convert spikes into activation
    [x,y,z] = spike2activation(R(:,t),x,y,z,parameter_Matrix,Lce,Fs);
    
    x_mat(:,t) = x;
    y_mat(:,t) = y;
    z_mat(:,t) = z;
    
    %% 
    f_i = z.*PTi_new';
    force(:,t) = f_i;
    
    Force(t) = sum(f_i);
end

%%
figure(1)
plot(time,Force)
%% Convert spike trian into activation
function [x,y,z] = spike2activation(R,x,y,z,parameter_Matrix,Lce,Fs)
S = parameter_Matrix(:,1); %7;
C = parameter_Matrix(:,2); %1.025;
k_1 = parameter_Matrix(:,3); %14.625;
k_2 = parameter_Matrix(:,4); %4.9375;
k_3 = parameter_Matrix(:,5)*Lce + parameter_Matrix(:,6); %17.41*Lce - 2.85;
k_4 = parameter_Matrix(:,7)*Lce + parameter_Matrix(:,8); %-7.67*Lce + 14.92;
tau_2 = parameter_Matrix(:,10); % 0.04;
N = parameter_Matrix(:,11)*Lce + parameter_Matrix(:,12); %-2.26*Lce + 4.20;
K = parameter_Matrix(:,13)*Lce + parameter_Matrix(:,14); %-0.044*Lce + 0.080;
 %4.475;

x_dot = k_1.*(C-x-y).*R - k_2.*x.*((C.*(S-1))+x+y)-(k_3.*x+k_4.*y).*(1-y);
y_dot = (1-y).*(k_3.*x-k_4.*y);
x = x_dot/Fs + x;
y = y_dot/Fs + y;
y_temp = y;
y_temp(y_temp<0) = 0;

y_int = y_temp.^N./(y_temp.^N+K.^N);

z_dot = (y_int-z)./tau_2;
z = z_dot/Fs + z; % activation

end

%% Sag
function [S] = sag_function(S,f_eff,Fs)
if f_eff < 0.1
    a_s = 1.76;
else
    a_s = 0.96;
end

T_s = 0.043;
S_dot = (a_s - S)./T_s;
S = S_dot/Fs + S;

end

%% Yield
function [Y] = yield_function(Y,V,Fs)
c_y = 0.35;
V_y = 0.1;
T_y = 0.2;
Y_dot = (1-c_y*(1-exp(-abs(V)/V_y))-Y)/T_y;
Y = Y_dot/Fs + Y;

end